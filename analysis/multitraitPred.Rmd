---
title: "Iterative Comparison"
output:
  workflowr::wflow_html:
    toc: true
    latex_engine: "xelatex"
    code_folding: "hide"
editor_options:
  chunk_output_type: console
---


```{r 0-setup, include=FALSE, warning=FALSE}
#regular
library(dplyr)
library(data.table)
library(ggplot2)
library(cowplot)
library(qqman)
library(doParallel)
library(viridis)
library(scales)


#models tested
library(qgg)
library(varbvs)
library(glmnet)
library(BGLR)



#options
options(bitmapType = "cairo")
options(error = function() traceback(3))

#seed
set.seed(123)


```

The overarching goal of this process is to predict the phenotype for starvation resistance, a continuous trait, by using gene expression data, another continuous trait. This is done using k-fold cross validation to create models based on a subset of the data and calculating the correlation of that model with the remaining partition. By repeating this process multiple times with different training and testing partitions, model bias can be significantly reduced and allows for calculation of average correlation coefficients for each model. The primary difference between the methods in question is the prior distribution used.


```{r setup}

#loop count and data limit
iter <- 50

#ggplot holder list
gg <- vector(mode='list', length=12)

```



The first main set of data used for this analysis is a matrix of gene expression by DGRP line matched to raw starvation resistance. A second cluster of data sets provided by the Morgante Lab includes information on Wolbachia infection status and inversion status by line along with functions to adjust phenotypic values based on these two factors.

```{r expression-data, eval=FALSE, message=FALSE}

#wolb infection and inversion status data with phenotype adjustment function
load("/data2/morgante_lab/data/dgrp/misc/adjustData.RData")

#expression data matched to line and starvation phenotype
xp_f <- fread("data/xp-f.txt")

# xp_m <- fread("data/xp-m.txt")

#setwd("C:/Users/noahk/OneDrive/Desktop/amogus")
#getwd()

#create matrix of only gene expression, trims line and starvation
X <- as.matrix(xp_f[,3:11340])
rownames(X) <- xp_f[,line]
W <- scale(X)

y_temp <- xp_f[,starvation]
dat <- data.frame(id=xp_f[,line], y=y_temp)
y <- adjustPheno(dat, "starvation")


#model to solve for, vector of ones
mu <- matrix(rep(1, length(y)), ncol=1)
#names(mu) <- paste0("line", 1:length(mu))
rownames(mu) <- xp_f[,line]
TRM <- tcrossprod(W)/ncol(W)

# k-fold parameters
n <- length(y)
fold <- 5


```


The matrix containing only gene expression by line data was then scaled to an absolute max of 1. along with this, a Translation Relationship Matrix was generated by taking the crossproduct of the scaled expression matrix and scaling it down by the number of genes.


5 was chosen for k-fold cross validation resulting in 39 lines per validation set and 159 lines per training set.


The following methods are currently implemented:

BGLR - Bayesian General Linear Regression has the capability to perform BayesC linear regression using a Gibbs Sampler. 

Under this, both GBLUP and BayesC have been implemented in single trait and multitrait prediction based methods.


```{r loop_qgg_gbayes, message=FALSE, eval=FALSE}


ids <- readRDS("data/id_bank.Rds")

registerDoParallel(cores = 1)

iter <- 1

i <- 1

corLoop <- foreach(i=1:iter) %dopar% {
  
  #result holder
  corResult <- rep(0, 5)
  
  #setup train and test sets with trait vectors
  #test_IDs <- sample(1:n, as.integer(n / fold))
  
  test_IDs <- unlist(ids[i])
  
  W_train <- W[-test_IDs,]
  W_test <- W[test_IDs,]
  y_train <- y[-test_IDs]
  y_test <- y[test_IDs]
  
  ### BGLR
  fitBGLR <- BGLR::BGLR(y_train, response_type = "gaussian", a=NULL, b=NULL, ETA = list(list(X=W_train, model="BayesC")), nIter = 500, burnIn = 200)
  
  y_calc <- predict(fitBGLR, W_test)
  
  corResult[5] <- cor(y_test, y_calc)
  
  length(y_calc)
  length(y_test)
  
  #Overall result
  corResult
  
}





corLoop <- foreach(i=1:iter) %dopar% {
  
  #result holder
  corResult <- rep(0, 5)
  
  #setup train and test sets with trait vectors
  #test_IDs <- sample(1:n, as.integer(n / fold))
  
  test_IDs <- unlist(ids[i])
  
  W_train <- W[-test_IDs,]
  W_test <- W[test_IDs,]
  y_train <- y[-test_IDs]
  y_test <- y[test_IDs]
  
  
  ### QGG::GREML
  fitGreml <- qgg::greml(y=y, X=mu, GRM=list(A=TRM), validate = matrix(test_IDs,ncol=1), verbose=FALSE)
  
  corResult[1] <- fitGreml$accuracy$Corr
  
  ### QGG::GBAYES-C
  fitC <- qgg::gbayes(y=y_train, W=W_train, method="bayesC", scaleY=FALSE, nit=50000, nburn=20000)
  
  # \hat{y}_test = W_{test} * \hat{b} + \hat{mu}
  y_calc <- W_test %*% fitC$b + mean(y_train)
  corResult[2] <- cor(y_test, y_calc)
  
  ### VARBVS
  fitVarb <- varbvs::varbvs(X = W_train, NULL, y=y_train, family = "gaussian", logodds=seq(-3.5,-1,0.1), sa = 1, verbose=TRUE)
  
  y_calc <- predict(fitVarb, X=W_test)
  corResult[3] <- cor(y_test, y_calc)
  
  ### GLMNET::LASSO
  fitlm <- glmnet::cv.glmnet(x=W_train, y=y_train, alpha=1)
  
  y_calc <- predict(fitlm, W_test, s="lambda.min")
  corResult[4] <- cor(y_test, y_calc)
  
  ### BGLR
  fitBGLR <- BGLR::BGLR(y_train, response_type = "gaussian", a=NULL, b=NULL,ETA = list(list(X=W_train, model="BayesC")), nIter = 50000, burnIn = 20000)
  
  y_calc <- predict(fitBGLR, W_test)
  corResult[5] <- cor(y_test, y_calc)
  
  #Overall result
  corResult
  
}



```


```{r multitrait, warning=FALSE}

###FEMALE

bayesC <- readRDS("snake/data/2_cor/bayesC_f_starvation.Rds")
gblup <- readRDS("snake/data/2_cor/gblup_f_starvation.Rds")

multigblupData <- readRDS('snake/data/2_cor/multigblup_f_starvation.Rds')
temp <- unlist(multigblupData)
multigblup <- temp[seq(1, length(temp), by=4)]
multigblupM <- temp[seq(4, length(temp), by=4)]

multibayesCData <- readRDS('snake/data/2_cor/multibayesC_f_starvation.Rds')
temp <- unlist(multibayesCData)
multibayesC <- temp[seq(1, length(temp), by=4)]
multibayesCM <- temp[seq(4, length(temp), by=4)]

temp <- c(gblup, bayesC, multigblup, multibayesC)

label <- c(rep("gblup", iter), rep("bayesC", iter), rep("multigblup", iter), rep("multibayesC", iter))

data <- data.table(cor=as.numeric(temp), method=label)

gg[[1]] <- ggplot(data, aes(x=method, y=cor, fill=method)) +
  geom_violin(color = NA, width = 0.65) +
  geom_boxplot(color='#440154FF', width = 0.15) +
  theme_minimal() +
  stat_summary(fun=mean, color='#440154FF', geom='point', 
               shape=18, size=3, show.legend=FALSE) +
  labs(x=NULL,y='Correlation between True and Predicted Phenotype',tag='F') +
  theme(legend.position='none',
        axis.text.x = element_text(angle = -45, size=10),
        text=element_text(size=10),
        plot.tag = element_text(size=15)) +
  scale_fill_viridis(begin = 0.4, end=0.9,discrete=TRUE)


print(paste0(c('bayesC', 'gblup', 'multibayesC', 'multigblup'),': ',c(mean(bayesC), mean(gblup), mean(multibayesC), mean(multigblup))))


```


```{r nultitrait-male}



bayesC <- readRDS("snake/data/2_cor/bayesC_m_starvation.Rds")
gblup <- readRDS("snake/data/2_cor/gblup_m_starvation.Rds")

multigblupData <- readRDS('snake/data/2_cor/multigblup_m_starvation.Rds')
temp <- unlist(multigblupData)
multigblup <- temp[seq(4, length(temp), by=4)]

multibayesCData <- readRDS('snake/data/2_cor/multibayesC_m_starvation.Rds')
temp <- unlist(multibayesCData)
multibayesC <- temp[seq(4, length(temp), by=4)]

temp <- c(gblup, bayesC, multigblup, multibayesC)

label <- c(rep("gblup", iter), rep("bayesC", iter), rep("multigblup", iter), rep("multibayesC", iter))

data <- data.table(cor=as.numeric(temp), method=label)

gg[[2]] <- ggplot(data, aes(x=method, y=cor, fill=method)) +
  geom_violin(color = NA, width = 0.65) +
  geom_boxplot(color='#440154FF', width = 0.15) +
  theme_minimal() +
  stat_summary(fun=mean, color='#440154FF', geom='point', 
               shape=18, size=3, show.legend=FALSE) +
  labs(x=NULL,y='Correlation between True and Predicted Phenotype',tag='M') +
  theme(legend.position='none',
        axis.text.x = element_text(angle = -45, size=10),
        text=element_text(size=10),
        plot.tag = element_text(size=15)) +
  scale_fill_viridis(begin = 0.4, end=0.9,discrete=TRUE)

print(paste0(c('bayesC', 'gblup', 'multibayesC', 'multigblup'),': ',c(mean(bayesC), mean(gblup), mean(multibayesC), mean(multigblup))))

```

### Correlation Coefficient Boxplots


```{r plot-print, warning=FALSE}

plot_grid(gg[[1]],gg[[2]], ncol=2)

```

### Runtimes

```{r runtime-print, warning=FALSE}
#plot_grid(gg[[3]],gg[[4]], ncol=2)

```




```{r debug, eval=FALSE}



#FEMALE
female <- c(bayesC=mean(bayesC),lasso=mean(lasso),rr=mean(rr),varbvs=mean(varbvs))

female
male

male <- c(bayesC=mean(bayesC),lasso=mean(na.omit(lasso)),rr=mean(rr),varbvs=mean(varbvs))


#MALE
male <- c(mean(bayesC),mean(lasso),mean(rr),mean(varbvs))



```



