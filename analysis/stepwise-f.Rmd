---
title: "Iterative Comparison - Female"
output:
  workflowr::wflow_html:
    toc: true
    latex_engine: "xelatex"
    code_folding: "hide"
editor_options:
  chunk_output_type: console
---
  
```{r 0-setup, include=FALSE, warning=FALSE}
#regular
library(dplyr)
library(data.table)
library(ggplot2)
library(cowplot)
library(qqman)
library(doParallel)

#models tested
library(qgg)
library(varbvs)
library(glmnet)

#options
options(bitmapType = "cairo")
options(error = function() traceback(3))

#seed
set.seed(1)

```


```{r setup}

#loop count and data limit
iter <- 48

#Parallel core count
#registerDoParallel(cores = 8)

#ggplot holder list
gg <- vector(mode='list', length=12)

# result storage elements
fit_greml <- vector(mode='list', length=iter)
fit_gbayesC <- vector(mode='list', length=iter)
fit_varbvs <- vector(mode='list', length=iter)
fit_glmnet <- vector(mode='list', length=iter)



```



```{r qgg_greml, eval=TRUE, message=FALSE}

dataFlag <- TRUE

if(dataFlag){

 #wolb infection and inversion status data with phenotype adjustment function
load("/data2/morgante_lab/data/dgrp/misc/adjustData.RData")

  
  #expression data matched to line and starvation phenotype
  xp_f <- fread("data/xp-f.txt")
  
 # xp_m <- fread("data/xp-m.txt")
  
  #setwd("C:/Users/noahk/OneDrive/Desktop/amogus")
  #getwd()
  
  #create matrix of only gene expression, trims line and starvation
  X <- as.matrix(xp_f[,3:11340])
  rownames(X) <- xp_f[,line]
  W <- scale(X)
  
  y_temp <- xp_f[,starvation]
  dat <- data.frame(id=xp_f[,line], y=y_temp)
  y <- adjustPheno(dat, "starvation")

} else{
  
  # Toy Data set, 200x100 matrix
  W <- matrix(rnorm(20000), ncol = 100)
  colnames(W) <- paste0("gene", 1:ncol(W))
  rownames(W) <- paste0("line", 1:nrow(W))
  
  #model uses genes 1:5 and 10:20
  y <- rowSums(W[, 1:5]) + rowSums(W[, 10:20]) + rnorm(nrow(W))

}

### qgg_greml

#model to solve for, vector of ones
mu <- matrix(rep(1, length(y)), ncol=1)
#names(mu) <- paste0("line", 1:length(mu))
rownames(mu) <- xp_f[,line]
TRM <- tcrossprod(W)/ncol(W)

# k-fold parameters
n <- length(y)
fold <- 10

iter <- 48

```


```{r trace-sample, eval=FALSE}
### sample analysis of gbayesC to show that convergence is working as expected 

test_IDs <- sample(1:n, as.integer(n / fold))
  
  W_train <- W[-test_IDs,]
  W_test <- W[test_IDs,]
  y_train <- y[-test_IDs]
  y_test <- y[test_IDs]
  

  ### GBAYES-C
  
  
  fitC <- qgg::gbayes(y=y_train, W=W_train, method="bayesC", scaleY=FALSE, nit=10000, nburn=5000)
  

```

```{r trace-sample-real}

    print(paste0("gbayesC trace plot sample"))

    # fit taken from one iteration, restored from Rds using code chunk shown above
    fitC <- readRDS("data/gbayesC-f.Rds")
    plotBayes(fit=list(fitC), what = "trace")


```


```{r loop_qgg_gbayes, message=FALSE, eval=FALSE}

#this runs on the same data sets as greml

### qgg_gBayesC
### https://www.rdocumentation.org/packages/qgg/versions/1.1.1/topics/gbayes

# Bayes C: uses a “rounded spike” (low-variance Gaussian) at origin many small effects can contribute to polygenic component, reduces the dimensionality of the model (makes Gibbs sampling feasible).

#Parallel Header
#tempResult <- 

iter <- 1
corLoop <- foreach(i=1:iter) %dopar% {

#Linear Header
#for(i in 1:iter){
  
  corResult <- (1:4)
  
  
  
  #setup train and test sets with trait vectors
  test_IDs <- sample(1:n, as.integer(n / fold))
  
  W_train <- W[-test_IDs,]
  W_test <- W[test_IDs,]
  y_train <- y[-test_IDs]
  y_test <- y[test_IDs]
  
  
  ### GREML, qgg package
  fitGreml <- qgg::greml(y=y, X=mu, GRM=list(A=TRM), validate = matrix(test_IDs,ncol=1), verbose=FALSE)
  
  #Store coeff directly
  fit_greml[[i]] <- fitGreml$accuracy$Corr
  
  corResult[1] <- fitGreml$accuracy$Corr

  
  
  ### GBAYES-C
  
  
  fitC <- qgg::gbayes(y=y_train, W=W_train, method="bayesC", scaleY=FALSE, nit=10000, nburn=5000)
  
  # expected/calculated value for y_test
  # \hat{y}_test = W_{test} * \hat{b} + \hat{mu}
  y_calc <- W_test %*% fitC$b + mean(y_train)
  
  # store coeff
  fit_gbayesC[[i]] <- cor(y_test, y_calc)
  
  corResult[2] <- cor(y_test, y_calc)
  
  if(i==1){
    print(paste0("gbayesC trace plots from validate set ",i))
    plotBayes(fit=list(fitC), what = "trace")
  }
    
  
  ### VARBVS
  fitVarb <- varbvs::varbvs(X = W_train, NULL, y=y_train, family = "gaussian", logodds=seq(-3.5,-1,0.1), sa = 1, verbose=FALSE)
  
  # \hat{y}_test = W_{test} * \hat{b} + \hat{mu}
  y_calc <- W_test %*% fitVarb$beta + mean(y_train)
  
  fit_varbvs[[i]] <- cor(y_test, y_calc)
  
  corResult[3] <- cor(y_test, y_calc)
  
  
  
  
  ### GLMNET  
  fitlm <- glmnet::cv.glmnet(x=W_train, y=y_train, alpha=1)
  

  b_hat <- glmnet::coef.glmnet(fitlm, s="lambda.min")


  y_int <- b_hat[1]

  b_hat <- b_hat[2:length(b_hat)]

  y_calc <- W_test %*% b_hat + y_int

  fit_glmnet[[i]] <- cor(y_test, y_calc)
  
  corResult[4] <- cor(y_test, y_calc)
  
  
  corResult

}



```


```{r listConversion}

# results loaded from correlation loop structure
corLoop <- readRDS("data/corLoop-f.rds")



for(i in 1:iter){
  fit_greml[[i]] <- corLoop[[i]][1]
  fit_gbayesC[[i]] <- corLoop[[i]][2]
  fit_varbvs[[i]] <- corLoop[[i]][3]
  fit_glmnet[[i]] <- corLoop[[i]][4]
}

```


```{r results-ggplot}

iter <- 48

bint <- 10

### qgg_greml

qgg_greml_data <- as.data.table(fit_greml)
qgg_greml_data <- transpose(qgg_greml_data)
colnames(qgg_greml_data) <- "cor"

#print(paste0("GREML"))
#print(paste0("Mean correlation coefficient: ", mean(qgg_greml_data[,cor])))
#print(paste0("Variance of correlation coefficient: ", var(qgg_greml_data)))

gg[[1]] <- ggplot(qgg_greml_data, aes(x=cor)) +
  geom_histogram(bins=bint, fill='red') +
  labs(x="Corr Coeff") +
  ggtitle("GREML CV Correlations Histogram")


### qgg_gbayesC

qgg_gbayesC_data <- as.data.table(fit_gbayesC)
qgg_gbayesC_data <- transpose(qgg_gbayesC_data)
colnames(qgg_gbayesC_data) <- "cor"

#print(paste0("gBayesC"))
#print(paste0("Mean correlation coefficient: ", mean(qgg_gbayesC_data[,cor])))
#print(paste0("Variance of correlation coefficient: ", var(qgg_gbayesC_data)))

gg[[2]] <- ggplot(qgg_gbayesC_data, aes(x=cor)) +
  geom_histogram(bins=bint, fill='red') +
  labs(x="Corr Coeff") +
  ggtitle("gBayesC Prediction Corr Histogram")


### VARBVS

varbvs_data <- as.data.table(fit_varbvs)
varbvs_data <- transpose(varbvs_data)
colnames(varbvs_data) <- "cor"

#print(paste0("VARBVS"))
#print(paste0("Mean correlation coefficient: ", mean(varbvs_data[,cor])))
#print(paste0("Variance of correlation coefficient: ", var(varbvs_data)))

gg[[3]] <- ggplot(varbvs_data, aes(x=cor)) +
  geom_histogram(bins=bint, fill='red') +
  labs(x="Corr Coeff") +
  ggtitle("varbvs Prediction Corr Histogram")


### GLMNET

glmnet_data <- as.data.table(fit_glmnet)
glmnet_data <- transpose(glmnet_data)
colnames(glmnet_data) <- "cor"

#print(paste0("GLMNET"))
#print(paste0("Mean correlation coefficient: ", mean(glmnet_data[,cor])))
#print(paste0("Variance of correlation coefficient: ", var(glmnet_data)))

gg[[4]] <- ggplot(glmnet_data, aes(x=cor)) +
  geom_histogram(bins=bint, fill='red') +
  labs(x="Corr Coeff") +
  ggtitle("glmnet Prediction Corr Histogram")

```




```{r results-means}
result <- data.table(method="greml", meanCoeff=mean(qgg_greml_data[,cor])) 
result[,varCoeff := var(qgg_greml_data)]
                    
temp <- data.table(method="gBayesC", meanCoeff=mean(qgg_gbayesC_data[,cor]))
temp[,varCoeff := var(qgg_gbayesC_data)]
result <- rbind(result, temp)

temp <- data.table(method="varbvs", meanCoeff=mean(varbvs_data[,cor]))
temp[,varCoeff := var(varbvs_data)]
result <- rbind(result, temp)

temp <- data.table(method="glmnet", meanCoeff=mean(glmnet_data[,cor]))
temp[,varCoeff := var(glmnet_data)]
result <- rbind(result, temp)

# Map the time of day to different fill colors
#gg[[5]] <- ggplot(data=result, aes(x=method, y=meanCoeff, fill=method)) +
    #geom_bar(stat="identity")

#boxplot(result$meanCoeff)

gg[[5]] <- ggplot(data=result, aes(x=method, y=meanCoeff, fill=method)) +
    geom_bar(stat="identity")



gg[[6]] <- ggplot(data=result, aes(x=method, y=varCoeff, fill=method)) +
    geom_bar(stat="identity")



#gg[[5]] <- ggplot(result, aes(x=meanCoeff)) + 
#  geom_boxplot() + 
#  coord_flip()

#gg[[6]] <- ggplot(result, aes(x=varCoeff)) + 
#  geom_boxplot() + 
#  coord_flip()



```



```{r plot-print}

print("Correlation coefficient histograms")

plot_grid(gg[[1]],gg[[2]],gg[[3]],gg[[4]], ncol=2)



print(paste0("Mean correlation coefficient and variance of coefficients by method"))

plot_grid(gg[[5]],gg[[6]], ncol=2)

#plot_grid(gg[[1]],gg[[2]], ncol=2)
#plot_grid(gg[[3]],gg[[4]], ncol=2)

```





