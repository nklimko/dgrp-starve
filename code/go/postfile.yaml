configfile: 'gofig.yaml'

wildcard_constraints:
    goset="[0-9]+"

GOSET=range(1,10+1,1)
RMAX=[0.8]
RGO=[0.01]
SEX=['f','m']

#    input:
#        expand("output/{sample}.processed.txt", sample=glob_wildcards("input/{sample}.txt").sample)

#first 5 are topfive m
SPARSE_M = ['GO.0035008', 'GO.0140042', 'GO.0007485', 'GO.0005811', 'GO.0045819', 'GO.0007297', 'GO.0034703', 'GO.1905515', 'GO.0090090', 'GO.0009966']
SPARSE_F =  glob_wildcards("data/go/03_goterms/sparsef100/{goterm}.Rds").goterm

GOTERM_F =  glob_wildcards("data/go/03_goterms/sexf/{goterm}.Rds").goterm
GOTERM_M = glob_wildcards("data/go/03_goterms/sexm/{goterm}.Rds").goterm

FULL_F = glob_wildcards("data/go/03_goterms/fullf/{goterm}").goterm
FULL_M = glob_wildcards("data/go/03_goterms/fullm/{goterm}").goterm
#GOTERM=['GO.0000002', 'GO.0048788', 'GO.0034614', 'GO.0007166', 'GO.0034388']

#main='data/go/24_goCor/{type}/{rmax}/{rgo}/{goterm}/bayesC_{goset}.Rds'

#all----
rule all:
  input: 
    #expand('data/go/03_goterms/termFlag_{sex}', sex=SEX)
    #expand('data/go/24_goCor/f/{rmax}/{rgo}/{gotermf}/bayesC_{goset}.Rds', gotermf=GOTERM_F, rgo=RGO, rmax=RMAX, goset=GOSET),
    #expand('data/go/24_goCor/m/{rmax}/{rgo}/{gotermm}/bayesC_{goset}.Rds', gotermm=GOTERM_M, rgo=RGO, rmax=RMAX, goset=GOSET),
    #expand('data/go/25_fit/sexf/{goterm}/bayesFull.Rds', goterm=FULL_F),
    #expand('data/go/25_fit/sexm/{goterm}/bayesFull.Rds', goterm=FULL_M),
    ##expand('data/go/40_all/sex{sex}/allData.Rds', sex=SEX),
    ##expand('data/go/33_metric/sexf/sparse/term{goterm}/rowData.Rds', goterm=FULL_F),
    #expand('data/go/33_metric/sexm/sparse/term{goterm}/rowData.Rds', goterm=SPARSE_M),
    #expand('data/go/33_metric/sexf/sparse/term{goterm}/rowData.Rds', goterm=SPARSE_F),
    #'data/go/40_all/sexm/sparseData.Rds',
    'data/go/testSPARSE_500lamb.Rds'
    
#takes raw Gen Annotation Formnat(.gaf) file and filters for df of (go term, gene)
rule goIndex:
  input:
    "data/go/00_raw/fb.gaf"
  output:
    "data/go/01_goIndex/goIndex"
  shell:
    """
    awk -F"\t" '{{print $5, $2}}' {input} > splicedCols
    sort -t$'\t' -n -k2 splicedCols > sortCols
    cat sortCols | uniq > {output}
    rm splicedCols
    rm sortCols
    """

#takes goIndex and matches FlyBase genes to column ids in males and females separately
#saves output to RDS with term in name
rule goTerms:
  input:
    script="code/go/goTerms.R",
    goPath="data/go/01_goIndex/goIndex",
    xpPath='data/01_matched/{sex}_starvation.Rds'
  output:
    "data/go/03_goterms/termFlag_{sex}"
  params:
    sex = lambda wildcards: str(wildcards.sex)
  shell:
    """
    Rscript {input.script} \
    --goPath {input.goPath} \
    --xpPath {input.xpPath} \
    --sex {params.sex}
    
    touch {output}
    """

#GO terms are specific to sex, as such all rules are halved

#engine of BayesC path, takes GO term and runs custom model spitting out correlation and runtime
rule bayesGO_F:
  input:
    script='code/go/bayesHome.R',
    data='data/01_matched/f_starvation.Rds',
    ids='data/02_ids/f/ids_{goset}.Rds',
    goPath='data/go/03_goterms/sexf/{goterm}.Rds'
  output:
    'data/go/24_goCor/f/{rmax}/{rgo}/{goterm}/bayesC_{goset}.Rds'
  params:
    goset = lambda wildcards: int(wildcards.goset),
    goterm = lambda wildcards: str(wildcards.goterm),
    rGO = lambda wildcards: str(wildcards.rgo),
    rMAX = lambda wildcards: str(wildcards.rmax)
  threads: 1
  shell:
    """
    mkdir -p data/bglr/sexf/go{params.rGO}/max{params.rMAX}/term{params.goterm}/id{params.goset}
    Rscript {input.script} \
      --inPath {input.data} \
      --idPath {input.ids} \
      --goPath {input.goPath} \
      --outPath {output} \
      --nIter 130000 \
      --burnIn 30000 \
      --thin 50 \
      --R2_max {params.rMAX} \
      --R2_GO {params.rGO} \
      --model BayesC \
      --saveAt data/bglr/sexf/go{params.rGO}/max{params.rMAX}/term{params.goterm}/id{params.goset}/smallfit_
    """
rule bayesGO_M:
  input:
    script='code/go/bayesHome.R',
    data='data/01_matched/m_starvation.Rds',
    ids='data/02_ids/m/ids_{goset}.Rds',
    goPath='data/go/03_goterms/sexm/{goterm}.Rds'
  output:
    'data/go/24_goCor/m/{rmax}/{rgo}/{goterm}/bayesC_{goset}.Rds'
  params:
    goset = lambda wildcards: int(wildcards.goset),
    goterm = lambda wildcards: str(wildcards.goterm),
    rGO = lambda wildcards: str(wildcards.rgo),
    rMAX = lambda wildcards: str(wildcards.rmax)
  threads: 1
  resources:
    jobweight=2
  shell:
    """
    mkdir -p data/bglr/sexm/go{params.rGO}/max{params.rMAX}/term{params.goterm}/id{params.goset}
    Rscript {input.script} \
      --inPath {input.data} \
      --idPath {input.ids} \
      --goPath {input.goPath} \
      --outPath {output} \
      --nIter 130000 \
      --burnIn 30000 \
      --thin 50 \
      --R2_max {params.rMAX} \
      --R2_GO {params.rGO} \
      --model BayesC \
      --saveAt data/bglr/sexm/go{params.rGO}/max{params.rMAX}/term{params.goterm}/id{params.goset}/smallfit_
    """

#aggregator for engine rule, groups all 25 replicates into point mean
rule filterBayesGO_F:
  input:
    script='code/go/filterGO.R',
    data=expand('data/go/24_goCor/f/{{rmax}}/{{rgo}}/{{goterm}}/bayesC_{goset}.Rds', goterm=GOTERM_F, rgo=RGO, rmax=RMAX, goset=GOSET)
  output:
    'data/go/33_metric/sexf/rmax{rmax}/rgo{rgo}/term{goterm}/rowData.Rds'
  threads: 1
  resources:
    jobweight=1
  shell:
    """
    Rscript {input.script} \
    --inPath {input.data} \
    --outPath {output}
    """
rule filterBayesGO_M:
  input:
    script='code/go/filterGO.R',
    data=expand('data/go/24_goCor/m/{{rmax}}/{{rgo}}/{{goterm}}/bayesC_{goset}.Rds', goterm=GOTERM_M, rgo=RGO, rmax=RMAX, goset=GOSET)
  output:
    'data/go/33_metric/sexm/rmax{rmax}/rgo{rgo}/term{goterm}/rowData.Rds'
  threads: 1
  resources:
    jobweight=1
  shell:
    """
    Rscript {input.script} \
    --inPath {input.data} \
    --outPath {output}
    """ 

#gathers all point means into one table
rule combineBayesGO_F:
  input:
    script='code/go/combineGO.R',
    data=expand('data/go/33_metric/sexf/rmax{rmax}/rgo{rgo}/term{goterm}/rowData.Rds', goterm=GOTERM_F, rgo=RGO, rmax=RMAX)
  output:
      'data/go/40_all/sexf/allData.Rds'
  threads: 1
  shell:
    """
    Rscript {input.script} \
    --dataList {input.data} \
    --outPath {output}
    """
rule combineBayesGO_M:
  input:
    script='code/go/combineGO.R',
    data=expand('data/go/33_metric/sexm/rmax{rmax}/rgo{rgo}/term{goterm}/rowData.Rds', goterm=GOTERM_M, rgo=RGO, rmax=RMAX)
  output:
      all='data/go/40_all/sexm/allData.Rds',
      top='data/go/40_all/sexm/topData.Rds'
  params: 
    cor=0.48
  threads: 1
  shell:
    """
    Rscript {input.script} \
    --dataList {input.data} \
    --cutoff {params.cor} \
    --allPath {output.all} \ 
    --topPath {output.top}
    """





#rerun of specific GO terms to include final model in saved RDS. Used for PIP checking
rule bayesFull_F:
  input:
    script='code/go/bayesFull.R',
    data='data/01_matched/f_starvation.Rds',
    goPath='data/go/03_goterms/sexf/{goterm}.Rds'
  output:
    'data/go/25_fit/sexf/{goterm}/bayesFull.Rds'
  params:
    goterm = lambda wildcards: str(wildcards.goterm),
    rGO = 0.01,
    rMAX = 0.8
  threads: 1
  shell:
    """
    mkdir -p data/bglr/sexf/go{params.rGO}/max{params.rMAX}/term{params.goterm}
    Rscript {input.script} \
      --inPath {input.data} \
      --goPath {input.goPath} \
      --outPath {output} \
      --nIter 130000 \
      --burnIn 30000 \
      --thin 50 \
      --R2_max {params.rMAX} \
      --R2_GO {params.rGO} \
      --model BayesC \
      --saveAt data/bglr/sexf/go{params.rGO}/max{params.rMAX}/term{params.goterm}/fullfit_
    """
rule bayesFull_M:
  input:
    script='code/go/bayesFull.R',
    data='data/01_matched/m_starvation.Rds',
    goPath='data/go/03_goterms/sexm/{goterm}.Rds'
  output:
    'data/go/25_fit/sexm/{goterm}/bayesFull.Rds'
  params:
    goterm = lambda wildcards: str(wildcards.goterm),
    rGO = 0.01,
    rMAX = 0.8
  threads: 1
  shell:
    """
    mkdir -p data/bglr/sexm/go{params.rGO}/max{params.rMAX}/term{params.goterm}
    Rscript {input.script} \
      --inPath {input.data} \
      --goPath {input.goPath} \
      --outPath {output} \
      --nIter 130000 \
      --burnIn 30000 \
      --thin 50 \
      --R2_max {params.rMAX} \
      --R2_GO {params.rGO} \
      --model BayesC \
      --saveAt data/bglr/sexm/go{params.rGO}/max{params.rMAX}/term{params.goterm}/fullfit_
    """


### Sparse GL

#statemandates dreamagined up by the ranged
#engine for sparsegl pipeline. same GO ids halved, different algorithm
rule sparGO_F:
  input:
    script='code/go/sparse.R',
    data='data/01_matched/f_starvation.Rds',
    ids='data/02_ids/f/ids_{goset}.Rds',
    goPath='data/go/03_goterms/sparsef100/{goterm}.Rds'
  output:
    'data/go/24_goCor/f/sparse/{goterm}/sparsegl_{goset}.Rds'
  params:
    goterm = lambda wildcards: str(wildcards.goterm),
    jobweight=2
  threads: 1
  shell:
    """
    mkdir -p data/go/24_goCor/f/sparse/{params.goterm}
    Rscript {input.script} \
      --inPath {input.data} \
      --idPath {input.ids} \
      --goPath {input.goPath} \
      --outPath {output}
      """
      
      
      
      
      
      
#aggregator for engine rule, groups all 25 replicates into point mean
rule filterSparseGO_F:
  input:
    script='code/go/filterSparse.R',
    data=expand('data/go/24_goCor/f/sparse/{goterm}/sparsegl_{goset}.Rds', goterm=SPARSE_F, goset=GOSET)
  output:
    'data/go/33_metric/sexf/sparse/term{goterm}/rowData.Rds'
  threads: 1
  resources:
    jobweight=1
  shell:
    """
    Rscript {input.script} \
    --inPath {input.data} \
    --outPath {output}
    """

rule sparGO_M:
  input:
    script='code/go/sparse.R', # might be code/method/sparse.R
    data='data/01_matched/m_starvation.Rds',
    ids='data/02_ids/m/ids_{goset}.Rds',
    goPath='data/go/03_goterms/sexm/{goterm}.Rds'
  output:
    'data/go/24_goCor/m/sparse/{goterm}/sparsegl_{goset}.Rds'
  params:
    goterm = lambda wildcards: str(wildcards.goterm),
    jobweight=2
  threads: 1
  shell:
    """
    mkdir -p data/go/24_goCor/m/sparse/{params.goterm}
    Rscript {input.script} \
      --inPath {input.data} \
      --idPath {input.ids} \
      --goPath {input.goPath} \
      --outPath {output}
    """
      
      #aggregator for engine rule, groups all 25 replicates into point mean
rule filterSparseGO_M:
  input:
    script='code/go/filterGO.R',
    data=expand('data/go/24_goCor/m/sparse/{{goterm}}/sparsegl_{goset}.Rds', goterm=SPARSE_M, goset=GOSET)
  output:
    'data/go/33_metric/sexm/sparse/term{goterm}/rowData.Rds'
  threads: 1
  resources:
    jobweight=1
  shell:
    """
    Rscript {input.script} \
    --inPath {input.data} \
    --outPath {output}
    """
    
rule combineSparseGO_M:
  input:
    script='code/go/combineGO.R',
    data=expand('data/go/33_metric/sexm/sparse/term{goterm}/rowData.Rds', goterm=SPARSE_M)
  output:
      'data/go/40_all/sexm/sparseData.Rds'
  threads: 1
  shell:
    """
    Rscript {input.script} \
    --dataList {input.data} \
    --outPath {output}
    """
    
    
    
rule sparGO_testF:
  input:
    script='code/go/sparseTemp.R',
    data='data/01_matched/f_starvation.Rds',
    ids='data/02_ids/f/ids_1.Rds',
    goPath='data/go/03_goterms/sparsef100/GO.0000002.Rds'
  output:
    'data/go/testSPARSE_500lamb.Rds'
  params:
    #goterm = lambda wildcards: str(wildcards.goterm),
    jobweight=2
  threads: 1
  shell:
    """
    Rscript {input.script} \
      --inPath {input.data} \
      --idPath {input.ids} \
      --goPath {input.goPath} \
      --outPath {output}
      """
    #mkdir -p data/go/24_goCor/f/sparse/GO.0000002
      
      